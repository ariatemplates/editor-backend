var oop = require('oop').oop;





var Limit = oop.Class({
	name: 'Range Limit',

	desc: 'A range limit represents the value of either the start or the end of the range. It has more information than a simple number value.',

	schema: {
		inputToSpec: {
			'Number': 'value',
			'String': 'value',
			'Boolean': 'inclusive',
			'Array': function(args) {
				return {
					value: args[0],
					inclusive: args[1],
					direction: args[2]
				}
			}
		},
		properties: [
			{
				names: ['value', 'val', 'number', 'nb'],
				type: oop.types.Number,
				default: 0
			},
			{
				names: ['inclusive', 'incl', 'include'],
				type: oop.types.Boolean,
				default: true
			},
			{
				names: ['direction', 'dir'],
				type: oop.types.String,
				default: 'up'
			}//,
			// {
			// 	names: ['direction', 'dir'],
			// 	type: oop.types.Enum(oop.types.String, ['up', 'down']),
			// 	default: 'up'
			// }
		]
	},

	properties: {
		'exclusive': {
			get: function() {return !this.inclusive},
			set: function(exclusive) {this.inclusive = !exclusive}
		}
	},

	factories: {
		'nb_bool': {args: {'value': 0, 'inclusive': 1}},
		'bool_nb': {args: {'inclusive': 0, 'value': 1}}
	},

	proto: {
		serialize: function() {
			return this.value + (this.inclusive ? '' : this.direction == 'up' ? '+' : '-');
		},

		eq: function(other) {
			other = Limit.factory(other);

			return (this.inclusive && other.inclusive || (this.inclusive == other.inclusive && this.direction == other.direction)) && this.value == other.value;
		},

		inf: function(other) {
			other = Limit.factory(other);

			if (this.value == other.value) {
				if (this.direction == other.direction) {
					// ~ 5 = 5, 5- = 5-, 5+ = 5+
					if (this.inclusive == other.inclusive) {
						// Equal
						return false;
					}

					// |-> inf ]-> ~ 5 < 5+
					if (this.direction == 'up') {
						return this.inclusive;
					}
					// <-[ in <-| ~ 5- < 5
					if (this.direction == 'down') {
						return this.exclusive;
					}
				}

				// this: |->
				// other: <-|
				if (this.direction == 'up') {
					return false;
				}

				// this: <-[, <-|
				// other: |->, ]->
				if (this.direction == 'down') {
					return other.exclusive || this.exclusive;
				}
			}

			return this.value < other.value;
		},
		sup: function(other) {
			return !this.eq(other) && !this.inf(other);
		},

		infOrEq: function(other) {return this.eq(other) || this.inf(other);},
		supOrEq: function(other) {return this.eq(other) || this.sup(other);}
	},

	statics: {
		parse: function(source) {
			var lastCharacter = source[source.length - 1];

			var value;
			var inclusive;
			var direction;

			if (lastCharacter == '+') {
				value = source.substring(0, source.length - 1);
				inclusive = false;
				direction = 'up';
			} else if (lastCharacter == '-') {
				value = source.substring(0, source.length - 1);
				inclusive = false;
				direction = 'down';
			} else {
				value = source;
				inclusive = true;
			}
			return Limit({
				value: value,
				inclusive: inclusive,
				direction: direction
			});
		}
	}
});





export.Limit = Limit;
