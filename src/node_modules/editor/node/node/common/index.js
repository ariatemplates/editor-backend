var prelude = require('prelude-ls');
var lodash = require('lodash');

var oop = require('oop').oop;

var string_util = require('std/string');

var NodeType = require('editor/node/type').NodeType;
var Location = require('editor/node/location').Location;





definition = {
	name: 'Node',

	statics: {
		merge: function(nodes) {
			if (nodes == null || nodes.length === 0) {
				throw Error('No input provided for merge method');
			}
			var newNodeSpec = {
				type: nodes[0].type,
				location: {
					start: nodes[0].location.start,
					end: nodes[nodes.length - 1].location.end
				}
			};
			var source = [];
			for (var i = 0, len = nodes.length; i < len; i++) {
				source.push(nodes[i].source);
			}
			newNodeSpec.source = source.join('');

			return new this(newNodeSpec);
		}
	},
	methods: {
		put: function(id, item) {
			if (item == null) {
				return this.flag(id);
			}

			if (item instanceof Node) {
				return this.add(id, item);
			}

			if (prelude.isType('Array', item) && item.length > 0 && item[0] instanceof Node) {
				return this.addList(id, item);
			}

			return this.set(id, item);
		},

		copy: function() {
			// Creates a new node with the same basic properties
			var newNode = Node(this);

			// Children --------------------------------------------------------

			for (var id in this.childrenIndex) {
				var child = this.childrenIndex[id];

				if (prelude.isType('Array', child)) {
					var newList = [];
					for (var i = 0, length = child.length; i < length; i++) {
						newList.push(child[i].copy());
					}
					newNode.addList(id, newList);
				} else {
					newNode.add(id, child.copy());
				}
			}

			// Properties ------------------------------------------------------

			for (var key in this.properties) {
				newNode.set(key, this.properties[key]);
			}

			// Flags -----------------------------------------------------------

			for (var key in this.flags) {
				if (this.flags[key]) {
					newNode.flag(key);
				}
			}

			// Return ----------------------------------------------------------

			return newNode;
		},

		/***********************************************************************
		 * Children management
		 **********************************************************************/

		add: function(id, child) {
			child = this._pushChild(id, child);
			this.childrenIndex[id] = child;

			return child;
		},

		addList: function(id, list) {
			var finalList = [];

			for (var index = 0, length = list.length; index < length; index++) {
				var child = this._pushChild(id, list[index]);
				finalList.push(child);
				child._listIndex = index;
			}
			this.childrenIndex[id] = finalList;

			return finalList;
		},

		/***********************************************************************
		 * Properties management
		 **********************************************************************/

		set: function(key, value) {
			this.properties[key] = value;

			return value;
		},

		get: function(key) {
			return this.properties[key];
		},

		/**
		 * Sets a boolean property aiming at categorizing the node.
		 */
		flag: function(name) {
			this.flags[name] = true;
			return name;
		},

		unflag: function(name) {
			if (this.flags[name] != null) {
				this.flags[name] = false;
			}
			return name;
		},

		is: function(name) {
			return this.flags[name] === true;
		},

		addError: function(error) {
			var errors = this.get('errors') || [];
			errors.push(error);
			this.set('errors', errors);
		},

		addWarning: function(warning) {
			var warnings = this.get('warnings') || [];
			warnings.push(warning);
			this.set('warnings', warnings);
		},

		moveContextLocation: function(offset) {
			var location = this.location;
			location.start.index += offset.index;
			// if (location.start.line == 1) { // if the current start location is not on the first line, then the column position will not be impacted
			// 	location.start.column += offset.column - 1;
			// }
			// location.start.line += offset.line - 1;
			location.end.index += offset.index;
			// if (location.end.line == 1) { // if the current end location is not on the first line, then the column position will not be impacted
			// 	location.end.column += offset.column - 1;
			// }
			// location.end.line += offset.line - 1;
			var children = this.children;
			if (children) {
				for (var i = 0, len = children.length; i < len; i++) {
					children[i].moveContextLocation(offset);
				}
			}
		},

		/***********************************************************************
		 * Traversing
		 **********************************************************************/

		traverse: function(cb, context) {
			if (context == null) {
				context = this;
			}

			cb.call(context, this);

			var children = this.children;
			for (var i = 0, length = children.length; i < length; i++) {
				children[i].traverse(cb, context);
			}
		},

		traverse2: {
			input: {
				inputToSpec: {
					'Function': 'cb'
				},
				properties: [
					{
						names: ['cb', 'callback', 'handler', 'func', 'fn', 'visitor', 'visit'],
						type: oop.types.Function,
						required: true
					},
					{
						names: ['type', 'traversal', 'order'],
						type: oop.types.String
					}
				]
			},

			process: function(spec) {
				if (spec.type == "depth-first") {
					this.traverse(spec.cb);
				} else {
					throw {
						msg: 'Traversal type not implemented',
						type: spec.type
					}
				}
			}
		},

		pick: function(predicate) {
			var list = [];

			if (prelude.isType('String', predicate)) {
				var flag = predicate;
				predicate = function(node) {
					return node.is(flag);
				}
			}

			if (!prelude.isType('Function', predicate)) {
				throw {
					msg: 'Given predicate is not a function, nor a flag.',
					predicate: predicate
				}
			}

			this.traverse(function(node) {
				if (predicate(node)) {
					list.push(node);
				}
			});

			return list;
		},

		map: function(transform) {
			var list = [];

			this.traverse(function(node) {
				list.push(transform(node));
			});

			return list;
		},

		pluck: function(property) {
			return this.map(function (node) {
				return node.property;
			});
		},

		toObject: function() {
			var flags = [];
			for (var key in this.flags) {
				if (this.flags[key] === true) {
					flags.push(key);
				}
			}

			var output = {
				type: NodeType.toJSON(this.type),
				location: Location.toJSON(this.location),
				children: []
			};

			if (Object.keys(this.properties).length != 0) {
				output.properties = this.properties;
			}

			if (flags.length > 0) {
				output.flags = flags.sort();
			}

			var children = this.children;

			for (var i = 0, length = children.length; i < length; i++) {
				output.children.push(children[i].toObject());
			}

			return output;
		},


		/***********************************************************************
		 * Checkings (for development essentially)
		 *
		 * TODO Use the new Range class to simplify algorithm. Maybe we'll have to create a new class to handle nicely a set of ranges.
		 **********************************************************************/

		checkCoverage: function() {
			var children = this.children;
			var reports = [];

			// Edge case: no child ---------------------------------------------
			// If it doesn't have children, sure it's covered

			if (children.length === 0) {
				return reports;
			}

			// Edge case: first child ------------------------------------------

			var firstChild = children[0];

			reports = reports.concat(firstChild.checkCoverage());

			var parentStart = this.location.start.index;
			var firstChildStart = firstChild.location.start.index;

			if (firstChildStart > parentStart) {
				reports.push({
					type: 'Missing first node',
					range: [parentStart, firstChildStart],
					inside: this.getId(),
					before: firstChild.getId()
				});
			}

			// Children check --------------------------------------------------
			// Every child checks that it is not to far from its previous one, and not inside or overlapping it!

			var previous = firstChild;
			for (var i = 1, length = children.length; i < length; i++) {
				var current = children[i];

				reports = reports.concat(current.checkCoverage());

				var previousStart = previous.location.start.index;
				var previousEnd = previous.location.end.index;

				var currentStart = current.location.start.index;
				var currentEnd = current.location.end.index;

				if (currentStart > previousEnd) {
					reports.push({
						msg: 'Missing node between two children',
						range: [previousEnd, currentStart],
						inside: this.getId(),
						after: previous.getId(),
						before: current.getId()
					});
				} else if (currentStart < previousEnd) {
					reports.push({
						msg: 'overlapping',
						range: [currentStart, previousEnd],
						inside: this.getId(),
						previous: previous.getId(),
						current: current.getId()
					});
				}

				previous = current;
			}

			// Edge case: last child ------------------------------------------

			var lastChild = children[children.length - 1];
			var parentEnd = this.location.end.index;
			var lastChildEnd = lastChild.location.end.index;
			if (lastChildEnd < parentEnd) {
				reports.push({
					msg: 'Missing final node',
					range: [lastChildEnd, parentEnd],
					inside: this.getId(),
					after: lastChild.getId()
				});
			}

			// Result ----------------------------------------------------------

			return reports;
		},

		/***********************************************************************
		 * Logging/debug/introspection
		 **********************************************************************/

		getId: function() {
			var list = prelude.map(function(node) {
				var key = node.key;

				if (key == null) {
					key = '<root>';
				} else {
					var index = node._listIndex;

					if (index != null) {
						key += '(' + index + ')';
					}
				}

				return key;
			}, this.path);

			return list.join(' - ');
		},

		getPosition: function() {
			return lodash.pluck(this.path, '_index').join('.');
		},

		simplify: function() {
			// id --------------------------------------------------------------

			var idParentPart = string_util.join(this._key, '.', this._listIndex);
			var id = string_util.join(this._index, ' - ', idParentPart);

			// type ------------------------------------------------------------

			var language = this.type.language;
			var element = this.type.element;

			var type = language == null || element == null ? null : language + "." + element;

			// location --------------------------------------------------------

			var start = this.location.start;
			var end = this.location.end;

			// loc = "L#line C#column (#start)"---
			var loc = start.line + "x" + start.column + "->" + end.line + "x" + end.column + "/" + start.index + "->" + end.index;

			// properties ------------------------------------------------------

			var props = this.properties;

			// flags ------------------------------------------------------

			var flags = [];
			for (var key in this.flags) {
				if (this.flags[key] === true) {
					flags.push(key);
				}
			}

			// children --------------------------------------------------------

			var children;
			if (this.children.length !== 0) {
				children = [];
				for (var i = 0, length = this.children.length; i < length; ++i) {
					children.push(this.children[i].simplify());
				}
			}

			// Output ----------------------------------------------------------

			var output = {};

			if (id != null) {
				output.id = id;
			}

			output.type = type;
			output.loc = loc;

			if (flags != null) {
				output.flags = flags;
			}

			if (props != null) {
				output.props = props;
			}

			if (children != null) {
				output.children = children;
			}

			return output;
		},


		simpleTree: function() {
			// Properties computation ------------------------------------------

			var simplified = this.simplify();
			var id = simplified.id != null ? simplified.id : 'root';
			var type = simplified.type;
			var loc = simplified.loc;
			var props = simplified.props != null ? simplified.props : {};
			var flags = simplified.flags.join(', ');


			var properties = [];
			for (var key in props) {
				properties.push(key + "=" + props[key]);
			}
			properties = properties.join(', ');


			// Object creation -------------------------------------------------

			key = id + ": " + type + " (" + loc + ") [" + properties + "] <" + flags + ">";

			var value = [];
			for (var i = 0, length = this.children.length; i < length; i++) {
				value.push(this.children[i].simpleTree());
			}

			var output = {};
			output[key] = value;
			return output;
		}
	}
};





Object.defineProperty(exports, 'definition', {
	get: function() {
		return Object.create(definition);
	}
});
