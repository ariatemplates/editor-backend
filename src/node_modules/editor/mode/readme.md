Mode

----

___DISCLAIMER___: this part needs review and work

# Services

## Parsing

___Describe here the model of a parser and of the data generated by the parser (node/graph, commonly known as AST) - maybe put the latter in a dedicated section, see the WEB-IDE project and also personal ones___

This is the core service, as without it you can't get the core model on which __every other service__ is based.

A parser returns a comprehensive model of a program, or part of it. It should also be able to handle updates of the model from parts of the whole program.

## Highlighting

Please refer to the [`highlight`](./highlight) submodule.

## Formatting

Formatting aims at changing a source code to give it a wanted and generally uniformed layout.

### Concept

The concept of formatting code is simple:

- input: a source code, should be a relevant piece of code
- output: a source code with the same semantics, but formatted. It is likely to have the same syntax, what changes being mainly the white spaces.

So the main part to update in the model is related to tokens, especially white spaces, and thus is about information of positions (and length).

### Impact

Formatting transforms the code, therefore it impacts almost all other features relying on positions:

- highlight: highlighting is implemented with ranges of text styles
- outline: the outline should remain the same, since the semantic should remain the same. However, if the outline either displays positions information or is linked to the editor (when you select a node in outline you jump to the corresponding position in the editor), it relies on positions
- ...

### Implementation

For now, the API only allows you to pass in a source code, and to receive the new source code.

It's up to the client (frontend) to compute lengths difference.

However, you can in the same request ask for other information to be sent, like highlighting and outlining (to avoid the overhead of making those requests by yourself after).

## Folding

Folding aims at giving teh possibility to hide or show back portions of the source code, generally based on semantics.

### Concept

The concept is rather simple.

A fold happens on a set of consecutive lines. Thus the output model of folding is a set of line ranges, possibly overlapping by the way.

How to compute these ranges is another story.

A foldable portion of source code is linked to semantics. In general, block statements are foldable, and every elements inside a block must be impacted.

After obtaining the AST of the source code, all nodes must be traversed. Only nodes corresponding to blocks will be processed.

Such a node should contain location information in the form of `line`, `column` (this feature is provided by the parsers I use). Just take the range of lines it spans and return it.

### Impact

This depends on frontends capabilities.

Folding doesn't change anything in the core model, it's just a visual feature. Therefore it might impact all features concerning display of the code, like for instance highlighting.

However, services like highlighting are based on the core model, and give position information related to this model, not what is visually displayed. The frontend should be able to adapt this information to the fact that portions of code are not _physically_ shown.

----

# API

## Methods

### Create a `Code` instance tied to the mode

Creates a code instance using this mode from the given source.

#### Names

- `create`


### Update the content of a `Code` instance

Updates the code models.

#### Names

- `update`



### Execute multiple services at once

Unique service that allows to call several of them with a unique node traversal.

#### Names

- `multiService`

#### Parameters

1. `code`
	- type: `Code`
1. `options`
	- type: `Object`
	- Keys represent the visitors to call, values are the extra parameters to pass to the methods of the visitors

#### Return

- type: `Object`
- It contains the response of every visitor.



### Call multiple visitors to process the AST

#### Names

- `callVisitors`

#### Parameters

1. `visitorsToCall`
	- type: `Object`
	- keys represent the visitors to call, values are the extra parameters to pass to the methods of the visitors
1. `method`
	- type: `String`
	- name of the method to call. Visitors implement 4 methods `start`, `emptyOutput`, `processNode`, `end`. `processNode` method receives the node that is currently being traversed as an argument
1. `args`
	- type: `Object`
	- First argument of the call
1. `callback`
	- type: `Function`
	- Function to be called at the end of the processing. It receives as first argument the visitor name, as second argument the value returned by the method



### Get a copy of the AST

Returns an AST.

#### Names

- `parse`

#### Description

Basically it removes circular links from the graph, and also _internal_ properties, especially the object shared between all nodes, which doesn't make sense since it's not part of the tree.

__WARNING__: this returns a copy of the graph, because we must not modify it directly!



### Validate the semantics of the code

Traverses the graph to look for errors and warnings.

#### Names

- `validate`

#### Parameters

1. `code`
	- type: `Code`

#### Return

- type: `Object`
- it contains the list of errors and warnings



### Get the stylesheet for highlighting

Returns the stylesheet used by this mode.

#### Names

- `stylesheet`


### Get a HTML rendering of highlighting

#### Names

- `html`

#### Backlog

- handle line endings more nicely



### Get folding ranges

Returns a list of _foldable_ lines ranges.

#### Names

- `fold`

#### Description

A range is a start line and an end line. Only "real" ranges are returned, that is you can be sure that the starts line is different from the end line.

_Foldable_ ranges are determined by block nodes. Every block is marked as potentially _foldable_. Then, blocks which don't span multiple lines are unmarked.

Also, to avoid folding handles collision, blocks that start on the same line are avoided: between two colliding blocks, we want to keep the most enclosing ones. For that, there is a simple rule, strongly based on hypothesis made from the nature of the graph:

- two blocks are likely to start on the same line only if they are contained in the same subtree
- the most enclosing one is the closest to the root



### Get a graph structure for various graph visualization libraries (web-based)

Returns analysis data about the graph representing the code, plus data to use for visual display of it.

#### Names

- `graph`

#### Description

For now, here are the available/planned formats: 

- `jit`
	- __unimplemented__
	- for JavaScript InfoVis Toolkit
- `cytoscape`
	- for Cytoscape
	- The easiest way of using Cytoscape.js is to explicitly specify separately nodes and their connections, that is edges. Therefore, an object containing a list of nodes and a list of edges is returned (`{nodes, edges}`).





# FIXME

## Highlighting

- ask the user of the mode (by instantiation or extension) to provide a way to get the stylesheet (not the static stylesheet itself, so we can do _hot_ changes)

## Outline

- why in the "specs" do I require a list of elements to be returned, while this will always be a single node (the root)? Or maybe I would like to avoid the root!





# Backlog

- remove code really tied to specific frontends. Namely, web-based one: 
	- `html`
	- `graph`
	- ...

## Highlighting

- be able to provide a default stylesheet, common for all modes? This would require to have the same token names...

### `highlight`

- add an option to return more information in some ranges, like the ones about line endings

## Folding: handle properly multiple blocks on one line

Think about the case where there are multiple multi-lines blocks on the same line: they overlap while one is ending and the other one is starting.

This would have some weird behavior when trying to fold them.

## New service: pairs matching

__Be able to return information about what matches in the source code__

Classical pairs matching, like brackets, or tags.

For instance, this code:

```html
<html></html>
```

would give a model like this:

```javascript
{
	matches: [
		{
			first: {start: 0, end: 1},
			second: {start: 5, end: 6}
		},
		{
			first: {start: 0, end: 6},
			second: {start: 6, end: 13}
		},
		{
			first: {start: 6, end: 7},
			second: {start: 12, end: 13}
		}
	]
}
```

with following remarks:

- `start` and `end` position are __0-based__ (stays consistent)
- `start` is __inclusive__, while `end` is __exclusive__ (stays consistent)
- omitting the end would give a default value being `start + 1`, to enclose one character
- caution as to be made with colliding pairs: here for instance if you are on an angle brackets, you are both on the brackets pairs and tags pair. However, this is up to the client to handle it properly: it might highlight both, like a stack.
