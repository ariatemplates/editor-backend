// ------------------------------------------------------------------------- 3rd

var prelude = require('prelude-ls');
var escapeHTML = require('escape-html');

var oop = require('oop').oop;
var dop = require('oop').dop;

// ---------------------------------------------------------------- internal std

var stderror = require('std/error');

var STDError = stderror.STDError;
var NotImplemented = stderror.NotImplemented;

// -------------------------------------------------------------------- internal

var Code = require('editor/code').Code;
var Parser = require('editor/pegjs-parser/parser').Parser;
var Stylesheet = require('editor/highlight/stylesheet').Stylesheet;
var OutlineNode = require('editor/outline/outline-node').OutlineNode;

var visitors = {
	"validate" : require('editor/validation/visitor').ValidationVisitor
};





/*******************************************************************************
 * Models
 ******************************************************************************/

var FoldOptions = oop.Class({
	name: 'Fold options',

	desc: 'Options for the folding service.',

	schema: {
		properties: [
			{
				names: ['length', 'size'],
				type: oop.types.Boolean,
				default: false,
				desc: 'This flag tells to specify a range as a couple of start offset and text length instead of start offset and end offset.'
			},
			{
				names: ['text', 'txt', 'char', 'chars', 'character', 'characters'],
				type: oop.types.Boolean,
				default: false,
				desc: 'This flag tells to use character offsets instead of line offsets to specify ranges.'
			},
			{
				names: ['0-based'],
				type: oop.types.Boolean,
				default: false,
				desc: 'This flag tells to use 0-based offsets instead of 1-based. This applies for both line and character offsets modes.'
			}
		]
	}
});






/*******************************************************************************
 * Class: Mode
 ******************************************************************************/

var Mode = oop.Class({
	name: 'Mode',

	schema: {
		properties: [
			{
				names: ['parser'],
				type: Parser,
				required: true
			},
			{
				names: ['stylesheet', 'style'],
				output: '_stylesheet',
				type: Stylesheet
			},
			{
				names: ['highlightDefaultStyleNodes'],
				type: oop.types.Array,
				default: []
			},
			{
				names: ['outlineRules', 'outline']
			}
		]
	},

	init: function() {
		if (!prelude.isType('Function', this.parser.parse)) {
			throw STDError({
				msg: 'Invalid given parser',
				parser: this.parser
			});
		}
	},



	prototype: {
		/***********************************************************************
		 * Init
		 **********************************************************************/

		create: function(source, extension) {
			return new Code(this.parser, source, extension);
		},


		/***********************************************************************
		 * Model
		 **********************************************************************/

		update: function(code, input) {
			code.resetCache();
			return code.update(input);
		},

		multiService: function(code, options) {
			var graph = code.graph;
			var response = {};

			if (graph == null) {
				this.callVisitors(options, "emptyOutput", null, function(visitorName, result) {
					response[visitorName] = result;
				});
				return response;
			}

			// Add cached results to the response and delete the corresponding service from options in order not run it again
			for (var visitor in options) {
				if (options.hasOwnProperty(visitor) && code.getCache(visitor) != null) {
					response[visitor] = code.getCache(visitor);
					delete options[visitor];
				}
			}

			if (Object.keys(options).length > 0) {
				this.callVisitors(options, "start", graph);
				var that = this;
				graph.traverse(function(node) {
					that.callVisitors(options, "processNode", node);
				});
				this.callVisitors(options, "end", null, function(visitorName, result) {
					response[visitorName] = result;
					code.setCache(visitorName, result);
				});
			}
			return response;
		},

		callVisitors: function(visitorsToCall, method, args, callback) {
			var result;
			for (var visitor in visitorsToCall) {
				if (visitorsToCall.hasOwnProperty(visitor) && visitors[visitor] != null) {
					result = visitors[visitor][method](args, visitorsToCall[visitor]);
					if (callback) {
						callback(visitor, result);
					}
				}
			}
		},


		/***********************************************************************
		 * Parse
		 **********************************************************************/

		parse: function(code, input) {
			var graph = code.graph;

			if (graph == null) {
				return {};
			}

			graph = graph.copy();

			graph.traverse(function(node) {
				delete node.parent;
				delete node.shared;

				delete node.childrenIndex;

				if (Object.keys(node.flags).length === 0) {
					delete node.flags;
				}
				if (Object.keys(node.properties).length === 0) {
					delete node.properties;
				}
			});

			return graph;
		},



		/***********************************************************************
		 * Highlight
		 **********************************************************************/

		stylesheet: function(code, input) {
			return this._stylesheet;
		},

		css: function() {
			return this._stylesheet.css();
		},

		html: function(code, input) {
			var source = code.source;

			var ranges = this.highlight(code, input).ranges;

			// Hack to append at the end any source code that has been taken into account by highlighting
			// This can happen only when the source code and the corresponding graph are not in sync, because parsing failed. There is more text that what the "highlighting thinks".

			var lastRange = ranges[ranges.length - 1];
			if (lastRange == null) {
				lastRange = {
					end: 0
				}
			}
			var rangesEnd = lastRange.end;
			if (rangesEnd < source.length) {
				ranges.push({style: '_unparsed', start: rangesEnd, end: source.length})
			}

			// -----

			var output = "";
			for (var i = 0, length = ranges.length; i < length; i++) {
				var range = ranges[i];

				var str = escapeHTML(source.substring(range.start, range.end));
				str = str.replace(/\r\n/g, '\n');
				str = str.replace(/\n/g, '<br/>');
				str = str.replace(/ /g, '&nbsp;');
				str = str.replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;');

				var style = '';
				if (range.style != '') {
					style = Stylesheet.CLASS_PREFIX + this._stylesheet.convertSelectorToClassName(range.style);
				}
				output += "<span class='" + Stylesheet.CLASS_PREFIX + Stylesheet.DEFAULT_CLASS + " " + style + "'>" + str + "</span>";
			}

			return {
				ranges: ranges,
				html: output
			};
		},

		highlight: function(code, input) {
			var graph = code.graph;

			if (graph == null) {
				return {ranges: []}; //XXX silent error
			}

			// Marks -----------------------------------------------------------

			var fakeParent = false;
			if (graph.parent == null) {
				fakeParent = true;
				graph.parent = {
					fullpath: graph.type.element
				};
			}

			var leaves = [];
			var stylesheet = this._stylesheet;
			// Compute marks based on the node full path, and, if none is applicable, get marks from parents and put them into their children, to have all leaves marked, even if their marks have style corresponding to some ancestor nodes' types.

			graph.traverse(function(node) {
				var fullpath = node.parent.fullpath + "." + node.type.element;
				node.fullpath = fullpath;
				var style = stylesheet.getStyleFromPath(fullpath);
				node.highlight = style != null ? {
					style: style
				} : node.parent.highlight;

				// detect whether it is a leaf
				if (node.children == null || node.children.length === 0) {
					leaves.push(node);
				}
			});


			if (fakeParent) {
				delete graph.parent;
 			}

			// Transforms ------------------------------------------------------

			var ranges = prelude.map(function(token) {
				return {
					start: token.location.start.index,
					end: token.location.end.index,
					style: token.highlight != null ? token.highlight.style : ''
				};
			}, leaves);

			// Collapses -------------------------------------------------------

			// Collapses consecutive ranges that have the same style

			var finalRanges = [];
			var lastStyle;
			while (ranges.length > 0) {
				var range = ranges.shift();
				if (range.style === lastStyle) {
					finalRanges[finalRanges.length - 1].end = range.end;
				} else {
					finalRanges.push(range);
					lastStyle = range.style;
				}
			}

			// Returns ---------------------------------------------------------

			return {
				ranges: finalRanges
				// lineFeedType: ''
			};
		},

		/***********************************************************************
		 * Validation
		 **********************************************************************/

		validate: function(code) {
			return this.multiService(code, {
				"validate" : null
			}).validate;
		},



		/***********************************************************************
		 * Outline
		 **********************************************************************/

		outline: function(code, input) {
			var type = dop.extractProperty(input, {names: ['type'], default: "full"});

			var graph = code.graph;

			if (graph == null) {
				return {}
			}

			var outline;
			if (type === "simpleTree") {
				outline = this._outlineSimpleTree(graph.simpleTree());
			} else if (type === "simple") {
				outline = this._outlineNode(graph);
			} else if (type === "full") {
				outline = this._outline(graph);
			}  else if (type === "toObject") {
				outline = {children : graph.toObject()};
			}

			return {
				tree: outline.children
			};
		},

		_outline: function(node) {
			// label -----------------------------------------------------------

			var label = node.key || '<root>';

			// children --------------------------------------------------------

			var children = [];

			// ---------------------------------------------- classic properties

			children.push('type: ' + node.type.element);

			children.push({
				label: 'location',
				children: [
					{
						label: 'start',
						children: [
							'index: ' + node.location.start.index,
							'line: ' + node.location.start.line,
							'column: ' + node.location.start.column
						]
					},
					{
						label: 'end',
						children: [
							'index: ' + node.location.end.index,
							'line: ' + node.location.end.line,
							'column: ' + node.location.end.column
						]
					}
				]
			});

			var indexes = [
				'index: ' + node.index,
				'id: ' + node.id
			];

			if (node._listIndex != null) {
				indexes.push('list index: ' + node._listIndex);
			}

			children.push({
				label: 'indexes',
				children: indexes
			});

			// ----------------------------------------------------------- flags

			var flags = [];
			for (var flag in node.flags) {
				if (node.flags[flag] === true) {
					flags.push(flag);
				}
			}

			children.push({
				label: 'flags',
				children: flags
			});

			// ------------------------------------------------------ properties

			var properties = [];
			for (var property in node.properties) {
				properties.push(property + ' = ' + node.properties[property]);
			};

			children.push({
				label: 'properties',
				children: properties
			});

			// --------------------------------------------------- node children

			var outlinedChildren = [];
			for (var i = 0, length = node.children.length; i < length; i++) {
				outlinedChildren.push(this._outline(node.children[i]));
			}

			children.push({
				label: 'children',
				children: outlinedChildren
			});

			// Result ----------------------------------------------------------

			return OutlineNode({
				label: label,
				children: children
			});
		},

		_outlineNode: function(node) {
			// label -----------------------------------------------------------

			var id = node.key || 'root';
			var type = node.type.element;

			var label = id + ": " + type;

			// children --------------------------------------------------------

			var children = node.children;

			var outlinedChildren = [];
			for (var i = 0, length = children.length; i < length; i++) {
				outlinedChildren.push(this._outlineNode(children[i]));
			}

			// Result ----------------------------------------------------------

			return {
				label: label,
				children: outlinedChildren
			};
		},

		_outlineSimpleTree: function(node) {
			// label -----------------------------------------------------------

			var label = Object.keys(node)[0];

			// children --------------------------------------------------------

			var children = node[label];

			var outlinedChildren = [];
			for (var i = 0, length = children.length; i < length; i++) {
				outlinedChildren.push(this._outlineSimpleTree(children[i]));
			}

			// Result ----------------------------------------------------------

			return {
				label: label,
				children: outlinedChildren
			};
		},



		/***********************************************************************
		 * Folding
		 **********************************************************************/

		fold: function(code, input) {
			var graph = code.graph;

			if (graph == null) {
				return {};
			}

			graph = graph.copy();

			var options = FoldOptions.factory(input);

			// Marks & filters -------------------------------------------------

			// Marks block nodes as potentially foldable
			graph.traverse(function(node) {
				if (node.is('block')) {
					if (node.location.start.line != node.location.end.line) {
						node.flag('foldable');
					}
				}
			});

			// Unmarks blocks that begin on the same line of other bigger blocks
			graph.traverse(function(node) {
				if (node.is('foldable') && node.index == 0) {
					var lineRef = node.location.start.line;
					node.traverse(function(descendant) {
						if (descendant !== node && descendant.location.start.line == lineRef) {
							descendant.unflag('foldable');
						}
					});
				}
			});

			// Extracts --------------------------------------------------------

			var blocks = graph.pick('foldable');

			// Transforms ------------------------------------------------------

			var text = options['text'] === true;
			var zeroBased = options['0-based'] === true;
			var length = options['length'] === true;

			var ranges = prelude.map(function(node) {
				var start;
				var end;

				// Text offsets or line indexes --------------------------------
				// 0-based or 1-based indexes/offsets --------------------------

				if (text) {
					start = node.location.start.index;
					end = node.location.end.index;
					// Text offsets are already 0-based, contrary to line and column indexes
				} else {
					start = node.location.start.line;
					end = node.location.end.line;

					if (zeroBased) {
						start -= 1;
						end -= 1;
					}
				}

				// {start, end} or {start, length} specifications --------------

				var result = {
					start: start
				}

				if (length) {
					result.length = end - start;
				} else {
					result.end = end
				}

				return result;
			}, blocks);

			// Returns ---------------------------------------------------------

			return {
				ranges: ranges
			}
		},

		/***********************************************************************
		 * Graph visualization: for client-side
		 **********************************************************************/

		graph: function(code, options) {
			var graph = code.graph;

			if (graph == null) {
				return {}
			}

			var library = dop.extractProperty(options, {
				names: ['library', 'lib', 'type', 'framework', 'engine', 'system'],
				type: oop.types.String,
				default: "cytoscape"
			});

			var graph_display = this._graphBuilder[library](graph);

			return {
				graph: graph_display
			}
		},

		_graphBuilder: {

			jit: function(graph) {
				throw "Unimplemented";
			},

			cytoscape: function(graph) {
				var nodes = [];
				var edges = [];

				graph.traverse(function(node) {
					var nodeId = node.getPosition();

					// Node data -----------------------------------------------
					// A new node to go into the list of nodes

					var nodeData = {id: nodeId};

					nodeData.source = node.source;
					nodeData.element = node.type.element;

					var children = node.children;
					if (children.length === 0) {
						nodeData.name = nodeData.source;
					} else {
						nodeData.name = nodeData.element;
					}
					nodes.push({data: nodeData});

					// Edges ---------------------------------------------------
					// Connection between this node and its children

					for (var i = children.length - 1; i >= 0; i--) {
						var child = children[i];
						var childId = child.getPosition();
						edges.push({data: {id: nodeId + '-' + childId, source: nodeId, target: childId}});
					}

				});

				return {
					nodes: nodes,
					edges: edges
				}
			}
		}
	}
});



exports.Mode = Mode;
