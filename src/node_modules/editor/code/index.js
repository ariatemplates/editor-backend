// --------------------------------------------------------------------- node.js

var pathlib = require('path');

// ------------------------------------------------------------------------- 3rd

var fs = require("fs.extra");

var prelude = require('prelude-ls');
var oop = require('oop').oop;

// -------------------------------------------------------------------- internal

var Parser = require('editor/pegjs-parser/parser').Parser;





/*******************************************************************************
 * Constants
 ******************************************************************************/

var OUTPUT_FOLDER = pathlib.join('__output__', 'failures');
fs.mkdirpSync(OUTPUT_FOLDER);





/*******************************************************************************
 * Models
 ******************************************************************************/

var sourcePropertyNames = ['text', 'txt', 'source', 'src', 'content', 'string', 'str'];

var updateInputSpec = {
	inputToSpec: {
		'String': function(input) {
			return {
				text: input,
				replace: true
			}
		}
	},
	properties: [
		{
			names: sourcePropertyNames,
			desc: 'The new text to set.',
			default: '',
			type: oop.types.String
		},
		{
			names: ['start', 'beginning', 'offset', 'index'],
			desc: 'INCLUSIVE, 0-based. The start index relative to the current code from which the given text will be set.',
			default: function() {return this.source.length;}, // appended text by default
			type: oop.types.Number
		},
		{
			names: ['end', 'stop'],
			desc: 'EXCLUSIVE, 0-based. The end index relative to the current code until which the given text will be set.',
			// inferred: 'start'
			type: oop.types.Number
		},
		{
			names: ['replace', 'erase', 'swap'],
			desc: 'A flag to ignore offsets and replace the entire current text with the given one.',
			default: false,
			type: oop.types.Boolean
		},
	]
};



/*******************************************************************************
 * Class: Code
 ******************************************************************************/

var Code = oop.class({
	name: 'Code',

	desc: 'Model for a source code. Kind of equivalent (but more specific) to the Document model in Eclipse.',

	constructor: function(parser, input, extension) {
		this.parser = parser;
		this.extension = extension;

		this._source = '';
		this._graph = undefined;
		this._servicesCache = {};

		if (input != null) {
			this.update(input);
		}
	},

	properties: [
		{
			names: sourcePropertyNames,
			desc: {
				get: function() {
					return this._source;
				},
				set: function(input) {
					this.updateSource(input);
				}
			}
		},
		{
			names: ['graph', 'tree', 'ast', 'nodes', 'node'],
			desc: {
				get: function() {
					return this._graph;
				}
			}
		}
	],

	methods: {
		update: {
			desc: 'Updates the models of the code given a diff description in the source code.',
			process: function(spec) {

				if (!prelude.isType('Array', spec)) {
					spec = [spec];
				}
				for (var i = 0; i < spec.length; i++) {
					this.updateSource(spec[i]);
				}
				// this.updateGraph.process.call(this, spec);

				try {
					this._graph = this.parser.parse(this.source, {extension : this.extension});
					return {
						state: 'uptodate'
					};
				} catch (exception) {
					var time = new Date();
					var output_folder = pathlib.join(
						OUTPUT_FOLDER,
						"" + time.getFullYear(),
						"" + (time.getMonth() + 1),
						"" + time.getDay(),
						"" + time.getHours() + "h",
						"" + time.getMinutes() + "m",
						"" + time.getSeconds() + "s",
						"" + time.getMilliseconds() + "ms"
					)
					fs.mkdirpSync(output_folder);

					fs.writeFileSync(
						pathlib.join(output_folder, 'source'),
						this.source,
						"utf-8"
					);

					fs.writeFileSync(
						pathlib.join(output_folder, 'exception'),
						exception.name + ": " + exception.message + "\n\n" + exception.stack,
						"utf-8"
					);

					return {
						state: 'pending',
						exception: exception
					}
				}
			}
		},

		updateSource: {
			desc: 'Updates the source.',
			chainable: true,
			input: updateInputSpec,

			process: function(spec) {
				if (spec.replace) {
					this._source = spec.text;
				} else {
					if (spec.end == null) {
						spec.end = spec.start;
					}

					this._source =
						this.source.substring(0, spec.start) +
						spec.text +
						this.source.substring(spec.end, this.source.length);
				}
			}
		},

		updateGraph: {
			desc: 'Updates the graph.',
			chainable: true,
			input: updateInputSpec,

			process: function(spec) {
				if (spec.replace) {
					this._graph = this.parser.parse(this.source, {extension : this.extension});
				} else {
					this._graph = this.parser.parse(this.source, {extension : this.extension});
				}
			}
		}
	},

	prototype: {
		setCache: function(key, value) {
			this._servicesCache[key] = value;
		},

		getCache: function(key) {
			return this._servicesCache[key];
		},

		resetCache: function() {
			this._servicesCache = {};
		}
	}
});



exports.Code = Code;
