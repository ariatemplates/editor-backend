var oop = require('oop').oop;

var Limit = require('./limit').Limit;





var Range = oop.Class({
	name: 'Range',

	desc: 'A range is an association of two numbers with some constraints: the start is below or equal to the end.',

	schema: {
		inputToSpec: {
			'Number': 'end',
			'String': 'end',
			'Array': function(args) {
				return {
					start: args[0],
					end: args[1]
				}
			}
		},
		properties: [
			{names: ['start', 'beginning', 'begin', 'min', 'first'], type: Limit, default: 0},
			{names: ['end', 'finish', 'stop', 'max', 'last'], type: Limit, default: 0/*, inferred: 'start*/}
		]
	},

	init: function() {
		if (this.end.value < this.start.value) this.end.value = this.start.value;
		this.start.direction = 'up';
		this.end.direction = 'down';

		if (this.start.value == this.end.value) {
			this.start.inclusive = this.end.inclusive = true;
		}
	},

	factories: {
		'range': {args: {'start': 0, 'end': 1}},
		'reversed': {args: {'end': 0, 'start': 1}}
	},

	properties: {
		'size': {
			get: function() {return this.end.value - this.start.value},
			set: function(length) {this.end.value = this.start.value + length}
		}
	},

	proto: {
		serialize: function() {
			var opening = '[';
			var closing = ']';

			if (!this.start.inclusive) opening = ']';
			if (!this.end.inclusive) closing = '[';

			return opening + this.start.value + ', ' + this.end.value + closing;
		},

		in: function(other) {
			other = Range.factory(other);

			return this.start.supOrEq(other.start) && this.end.infOrEq(other.end);
		},

		contains: function(limit) {
			limit = Limit.factory(limit);

			return limit.supOrEq(this.start) && limit.infOrEq(this.end);
		},

		overlaps: function(other) {
			other = Range.factory(other);

			return {
				left: this.start.inf(other.start) && this.end.supOrEq(other.start),
				right: this.end.sup(other.end) && this.start.infOrEq(other.end)
			}

			return {
				left: (this.start.value < other.start.value && this.end.value > other.start.value),
				right: (this.end.value > other.end.value && this.start.value < other.end.value)
			}
		}
	},

	statics: {
		parse: function(source) {
			var startInclusive = source[0] === '[';
			var endInclusive = source[source.length - 1] === ']';

			var numbers = source.substring(1, source.length - 1).split(', ');
			var startValue = numbers[0];
			var endValue = numbers[1];

			return Range({
				start: {
					value: startValue,
					inclusive: startInclusive
				},
				end: {
					value: endValue,
					inclusive: endInclusive
				}
			});
		},
	}
});





exports.Range = Range;
